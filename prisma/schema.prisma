// schema.prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["linux-arm64-openssl-1.1.x", "darwin-arm64"]
}

generator jsonSchema {
  provider = "prisma-json-schema-generator"
  output   = "./generated/json-schema"
}

model User {
  userId              Int               @id @default(autoincrement())
  walletAddress       String            @unique
  phoneNumber         String            @default("")
  profilePic          String            @default("")
  bannerPic           String            @default("")
  displayName         String            @default("")
  username            String            @default("")
  email               String            @unique
  walletAddress       String            @unique
  phoneNumber         String            @default("")
  profilePic          String            @default("")
  bannerPic           String            @default("")
  displayName         String            @default("")
  username            String            @default("")
  email               String            @unique
  notificationBySMS   Boolean           @default(true)
  notificationByEmail Boolean           @default(true)
  createdCollections  Collection[]      @relation(name: "createdCollections")
  createdCollections  Collection[]      @relation(name: "createdCollections")
  createdCommunities  Community[]       @relation(name: "createdCommunities")
  joinedCommunities   Community[]       @relation(name: "joinedCommunities")
  joinedChannels      UsersOnChannels[]
  posts               Post[]            @relation(name: "creator")
  likedPosts          Post[]            @relation(name: "likedPosts")
  comments            Comment[]         @relation(name: "commenter")
  likedComments       Comment[]         @relation(name: "likedComments")
  tickets             Ticket[]
  tickets             Ticket[]        
}

model Post {
  postId    Int       @id @default(autoincrement())
  title     String
  content   String
  date      DateTime  @default(now())
  media     String[]
  isPinned  Boolean   @default(false)
  creator   User      @relation(name: "creator", fields: [creatorId], references: [userId])
  creatorId Int
  channel   Channel   @relation(fields: [channelId], references: [channelId])
  channelId Int
  likes     User[]    @relation(name: "likedPosts")
  comments  Comment[]
  postId    Int       @id @default(autoincrement())
  title     String
  content   String
  date      DateTime  @default(now())
  media     String[]
  isPinned  Boolean   @default(false)
  creator   User      @relation(name: "creator", fields: [creatorId], references: [userId])
  creatorId Int
  channel   Channel   @relation(fields: [channelId], references: [channelId])
  channelId Int
  likes     User[]    @relation(name: "likedPosts")
  comments  Comment[]
}

model Community {
  communityId   Int           @id @default(autoincrement())
  name          String
  description   String
  profilePic    String
  tags          String[]
  maxMembers    Int           @default(100)
  communityType CommunityType @default(NFT)
  creator       User          @relation(name: "createdCommunities", fields: [userId], references: [userId])
  userId        Int
  creator       User          @relation(name: "createdCommunities", fields: [userId], references: [userId])
  userId        Int
  members       User[]        @relation(name: "joinedCommunities")
  channels      Channel[]
}

model Channel {
  channelId   Int               @id @default(autoincrement())
  channelId   Int               @id @default(autoincrement())
  name        String
  description String
  channelType ChannelType       @default(REGULAR)
  members     UsersOnChannels[]
  community   Community         @relation(fields: [communityId], references: [communityId])
  communityId Int
  posts       Post[]

  @@unique([communityId, name])
  @@unique([communityId, name])
}

model UsersOnChannels {
  user      User    @relation(fields: [userId], references: [userId])
  userId    Int
  channel   Channel @relation(fields: [channelId], references: [channelId])
  channelId Int
  user      User    @relation(fields: [userId], references: [userId])
  userId    Int
  channel   Channel @relation(fields: [channelId], references: [channelId])
  channelId Int

  @@id([userId, channelId])
  @@id([userId, channelId])
}

model Comment {
  commentId       Int       @id @default(autoincrement())
  content         String
  date            DateTime  @default(now())
  post            Post      @relation(fields: [postId], references: [postId])
  postId          Int
  commenter       User      @relation(name: "commenter", fields: [userId], references: [userId])
  userId          Int
  likes           User[]    @relation(name: "likedComments")
  originalComment Comment?  @relation(name: "replies", fields: [commentId], references: [commentId])
  originalComment Comment?  @relation(name: "replies", fields: [commentId], references: [commentId])
  replies         Comment[] @relation(name: "replies")
}

model Event {
  eventId            Int            @id @default(autoincrement())
  eventName          String         @default("")
  category           CategoryType[]
  address            Address        @relation(fields: [addressId], references: [addressId])
  addressId          Int
  startDate          DateTime       @default(now())
  endDate            DateTime       @default(now())
  images             String[]
  summary            String         @default("")
  description        String         @default("")
  visibilityType     VisibilityType
  privacyType        PrivacyType
  eventBannerPicture String         @default("")
  eventImage         String         @default("")
  maxAttendee        Int            @default(0)
  publishType        PublishType
  publishStartDate   DateTime       @default(now())
  tickets            Ticket[]
  ticketURIs         String[]
  scAddress          String
}

enum PublishType {
  NOW
  LATER
}

model Address {
  addressId    Int     @id @default(autoincrement())
  locationName String
  address1     String
  address2     String
  postalCode   String
  Event        Event[]
}

model Ticket {
  ticketId            Int         @id @default(autoincrement())
  name                String      @default("")
  totalTicketSupply   Int         @default(0)
  currentTicketSupply Int         @default(0)
  price               Float       @default(0)
  startDate           DateTime    @default(now())
  endDate             DateTime    @default(now())
  description         String      @default("")
  event               Event       @relation(references: [eventId], fields: [eventId], onDelete: Cascade)
  eventId             Int
  promotion           Promotion[]
  users               User[]
  ticketId            Int         @id @default(autoincrement())
  name                String      @default("")
  totalTicketSupply   Int         @default(0)
  currentTicketSupply Int         @default(0)
  price               Float       @default(0)
  startDate           DateTime    @default(now())
  endDate             DateTime    @default(now())
  description         String      @default("")
  event               Event       @relation(references: [eventId], fields: [eventId], onDelete: Cascade)
  eventId             Int
  promotion           Promotion[]
  users               User[]   
}

model Promotion {
  promotionId    Int           @id @default(autoincrement())
  name           String        @default("")
  name           String        @default("")
  promotionType  PromotionType
  promotionValue Float         @default(0)
  quantity       Int           @default(0)
  startDate      DateTime      @default(now())
  endDate        DateTime      @default(now())
  promotionValue Float         @default(0)
  quantity       Int           @default(0)
  startDate      DateTime      @default(now())
  endDate        DateTime      @default(now())
  ticket         Ticket        @relation(references: [ticketId], fields: [ticketId], onDelete: Cascade)
  ticketId       Int
}

enum CategoryType {
  AUTO_BOAT_AIR
  BUSINESS_PROFESSIONAL
  CHARITY_CAUSES
  COMMUNITY_CULTURE
  FAMILY_EDUCATION
  FASHION_BEAUTY
  FILM_MEDIA_ENTERTAINMENT
  FOOD_DRINK
  GOVERNMENT_POLITICS
  HEALTH_WELLNESS
  HOBBIES_SPECIAL_INTEREST
  HOME_LIFESTYLE
  PERFORMING_VISUAL_ARTS
  RELIGION_SPIRITUALITY
  SCHOOL_ACTIVITIES
  SCIENCE_TECHNOLOGY
  SEASONAL_HOLIDAY
  SPORTS_FITNESS
  TRAVEL_OUTDOOR
}

enum VisibilityType {
  DRAFT
  PUBLISHED
}

enum PrivacyType {
  PUBLIC
  PRIVATE
}

enum CommunityType {
  NFT
  CRYPTO
}

enum ChannelType {
  REGULAR
  PREMIUM
  PRIVATE
}

enum PromotionType {
  LIMITED
  UNLIMITED
}

model Collection {
  collectionId    Int               @id @default(autoincrement())
  description     String            @unique
  fixedPrice      Float
  currency        Currency          @default(USD)
  collectionState CollectionState   @default(CREATED)
  collections     CollectionMedia[]
  creator         User              @relation(name: "createdCollections", fields: [creatorId], references: [userId])
  creatorId       Int
}

enum CollectionState {
  CREATED
  ON_SALE
  SOLD
}

enum Currency {
  USD
  ETH
  BTC
  USDC
}

model CollectionMedia {
  collectionMediaId Int        @id @default(autoincrement())
  media             String
  description       String
  numOfMerch        Int
  collection        Collection @relation(fields: [collectionId], references: [collectionId], onDelete: Cascade)
  collectionId      Int
}
